1a) stty allows for terminal settings to be changed and man 1 stty displays all the special characters which can be changed and intr CHAR allows for CHAR to send an interupt symbol. so $ stty intr ^i.
1b) When trying to write to the spot in RAM with address 0 (NULL), the kernal raises a seg fault. This will move the program to the handler function established before. This would increase the cnt, and when it returns it would try the same operation again, and it would fail again, and this would increment cnt again. This results in an infinite loop. 1c) SIGKILL and SIGSTOP
1d) When a program is attempting to write in the  background, SIGTTIN (for reading from tty) or SIGGTOU (for writing to tty in certain circumstances) signals are sent which stop the process. However, writing to the terminal can betricky as SIGTTOU may not always be sent which can be configured (if TOSTOP is set then all writes to the terminal trigger SIGTTOU). Assuming that either SIGTTOU or SIGTTIN was raised than running fg would result in the SIGCONT signal being sent by the bash shell as the program is now being resumed from its stopped state. 

1e) Since standard signals are not queued, when a signal is masked by a process and receives multiple instances of a signal the pending signals array will only raise one bit for a pending signal. This means there is no count of how many times each signal was sent so signal #1 will only be sent one time. However, if a real time signal (on a modern Version of UNIX) such as SIGRtMIN #35 is sent it is queued meaning that signal would be sent 20 times. 

2a) No, this program should never print ABA, because writes of less than 4K in size happen atomically (for pipes). We are writing 1K at a time for CHILD('A') and CHILD('B'), which is less than the threshold of 4k. 
 
2b) If the line close(pp[1]) is not included in the code than the  program will hang as close(pp[1]) allows for an EOF condition to be generated. This would allow for read to eventually return 0 and exit the while loop, otherwise the program would hang as read would never reach an EOF condition allowing it to return 0. 
